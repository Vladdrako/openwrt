diff --git a/block/blk.h b/block/blk.h
index 8c96b0c90c48..40bf352b0a72 100644
--- a/block/blk.h
+++ b/block/blk.h
@@ -346,6 +346,7 @@ void blk_free_ext_minor(unsigned int minor);
 #define ADDPART_FLAG_NONE	0
 #define ADDPART_FLAG_RAID	1
 #define ADDPART_FLAG_WHOLEDISK	2
+#define ADDPART_FLAG_ROOTDEV	4
 int bdev_add_partition(struct gendisk *disk, int partno, sector_t start,
 		sector_t length);
 int bdev_del_partition(struct gendisk *disk, int partno);
diff --git a/block/partitions/Kconfig b/block/partitions/Kconfig
index 278593b8e4e9..d4cd2f36ea95 100644
--- a/block/partitions/Kconfig
+++ b/block/partitions/Kconfig
@@ -101,6 +101,13 @@ config ATARI_PARTITION
 	  Say Y here if you would like to use hard disks under Linux which
 	  were partitioned under the Atari OS.
 
+config FIT_PARTITION
+	bool "Flattened-Image-Tree (FIT) partition support" if PARTITION_ADVANCED
+	default n
+	help
+	  Say Y here if your system needs to mount the filesystem part of
+	  a Flattened-Image-Tree (FIT) image commonly used with Das U-Boot.
+
 config IBM_PARTITION
 	bool "IBM disk label and partition support"
 	depends on PARTITION_ADVANCED && S390
diff --git a/block/partitions/Makefile b/block/partitions/Makefile
index a7f05cdb02a8..d319eb1deba9 100644
--- a/block/partitions/Makefile
+++ b/block/partitions/Makefile
@@ -8,6 +8,7 @@ obj-$(CONFIG_ACORN_PARTITION) += acorn.o
 obj-$(CONFIG_AMIGA_PARTITION) += amiga.o
 obj-$(CONFIG_ATARI_PARTITION) += atari.o
 obj-$(CONFIG_AIX_PARTITION) += aix.o
+obj-$(CONFIG_FIT_PARTITION) += fit.o
 obj-$(CONFIG_CMDLINE_PARTITION) += cmdline.o
 obj-$(CONFIG_MAC_PARTITION) += mac.o
 obj-$(CONFIG_LDM_PARTITION) += ldm.o
diff --git a/block/partitions/check.h b/block/partitions/check.h
index d5b28e309d64..1b2fd18b2480 100644
--- a/block/partitions/check.h
+++ b/block/partitions/check.h
@@ -58,6 +58,7 @@ int amiga_partition(struct parsed_partitions *state);
 int atari_partition(struct parsed_partitions *state);
 int cmdline_partition(struct parsed_partitions *state);
 int efi_partition(struct parsed_partitions *state);
+int fit_partition(struct parsed_partitions *state);
 int ibm_partition(struct parsed_partitions *);
 int karma_partition(struct parsed_partitions *state);
 int ldm_partition(struct parsed_partitions *state);
@@ -68,3 +69,5 @@ int sgi_partition(struct parsed_partitions *state);
 int sun_partition(struct parsed_partitions *state);
 int sysv68_partition(struct parsed_partitions *state);
 int ultrix_partition(struct parsed_partitions *state);
+
+int parse_fit_partitions(struct parsed_partitions *state, u64 start_sector, u64 nr_sectors, int *slot, int add_remain);
diff --git a/block/partitions/core.c b/block/partitions/core.c
index 58c4c362c94f..fea4e1f9ccb3 100644
--- a/block/partitions/core.c
+++ b/block/partitions/core.c
@@ -11,6 +11,10 @@
 #include <linux/vmalloc.h>
 #include <linux/blktrace_api.h>
 #include <linux/raid/detect.h>
+#ifdef CONFIG_FIT_PARTITION
+#include <linux/root_dev.h>
+#endif
+
 #include "check.h"
 
 static int (*check_part[])(struct parsed_partitions *) = {
@@ -47,6 +51,9 @@ static int (*check_part[])(struct parsed_partitions *) = {
 #ifdef CONFIG_EFI_PARTITION
 	efi_partition,		/* this must come before msdos */
 #endif
+#ifdef CONFIG_FIT_PARTITION
+	fit_partition,
+#endif
 #ifdef CONFIG_SGI_PARTITION
 	sgi_partition,
 #endif
@@ -217,6 +224,18 @@ static ssize_t part_discard_alignment_show(struct device *dev,
 				bdev->bd_start_sect));
 }
 
+static ssize_t part_name_show(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct block_device *p = dev_to_bdev(dev);
+
+	if (p->bd_meta_info && p->bd_meta_info->volname)
+		return sprintf(buf, "%s\n", p->bd_meta_info->volname);
+
+	buf[0] = '\0';
+	return 0;
+}
+
 static DEVICE_ATTR(partition, 0444, part_partition_show, NULL);
 static DEVICE_ATTR(start, 0444, part_start_show, NULL);
 static DEVICE_ATTR(size, 0444, part_size_show, NULL);
@@ -225,6 +244,7 @@ static DEVICE_ATTR(alignment_offset, 0444, part_alignment_offset_show, NULL);
 static DEVICE_ATTR(discard_alignment, 0444, part_discard_alignment_show, NULL);
 static DEVICE_ATTR(stat, 0444, part_stat_show, NULL);
 static DEVICE_ATTR(inflight, 0444, part_inflight_show, NULL);
+static DEVICE_ATTR(name, 0444, part_name_show, NULL);
 #ifdef CONFIG_FAIL_MAKE_REQUEST
 static struct device_attribute dev_attr_fail =
 	__ATTR(make-it-fail, 0644, part_fail_show, part_fail_store);
@@ -239,6 +259,7 @@ static struct attribute *part_attrs[] = {
 	&dev_attr_discard_alignment.attr,
 	&dev_attr_stat.attr,
 	&dev_attr_inflight.attr,
+	&dev_attr_name.attr,
 #ifdef CONFIG_FAIL_MAKE_REQUEST
 	&dev_attr_fail.attr,
 #endif
@@ -596,6 +617,11 @@ static bool blk_add_partition(struct gendisk *disk,
 	    (state->parts[p].flags & ADDPART_FLAG_RAID))
 		md_autodetect_dev(part->bd_dev);
 
+#ifdef CONFIG_FIT_PARTITION
+	if ((state->parts[p].flags & ADDPART_FLAG_ROOTDEV) && ROOT_DEV == 0)
+		ROOT_DEV = part_to_dev(part)->devt;
+#endif
+
 	return true;
 }
 
diff --git a/block/partitions/efi.c b/block/partitions/efi.c
index 7ca5c4c374d4..9ecd2b3d5674 100644
--- a/block/partitions/efi.c
+++ b/block/partitions/efi.c
@@ -716,6 +716,9 @@ int efi_partition(struct parsed_partitions *state)
 	gpt_entry *ptes = NULL;
 	u32 i;
 	unsigned ssz = queue_logical_block_size(state->disk->queue) / 512;
+#ifdef CONFIG_FIT_PARTITION
+	u32 extra_slot = 64;
+#endif
 
 	if (!find_valid_gpt(state, &gpt, &ptes) || !gpt || !ptes) {
 		kfree(gpt);
@@ -749,6 +752,11 @@ int efi_partition(struct parsed_partitions *state)
 				ARRAY_SIZE(ptes[i].partition_name));
 		utf16_le_to_7bit(ptes[i].partition_name, label_max, info->volname);
 		state->parts[i + 1].has_info = true;
+#ifdef CONFIG_FIT_PARTITION
+		/* If this is a U-Boot FIT volume it may have subpartitions */
+		if (!efi_guidcmp(ptes[i].partition_type_guid, PARTITION_LINUX_FIT_GUID))
+			(void) parse_fit_partitions(state, start * ssz, size * ssz, &extra_slot, 1);
+#endif
 	}
 	kfree(ptes);
 	kfree(gpt);
diff --git a/block/partitions/efi.h b/block/partitions/efi.h
index 8cc2b88d0aa8..b5807e35bafc 100644
--- a/block/partitions/efi.h
+++ b/block/partitions/efi.h
@@ -52,6 +52,9 @@
 #define PARTITION_LINUX_LVM_GUID \
     EFI_GUID( 0xe6d6d379, 0xf507, 0x44c2, \
               0xa2, 0x3c, 0x23, 0x8f, 0x2a, 0x3d, 0xf9, 0x28)
+#define PARTITION_LINUX_FIT_GUID \
+    EFI_GUID( 0xcae9be83, 0xb15f, 0x49cc, \
+              0x86, 0x3f, 0x08, 0x1b, 0x74, 0x4a, 0x2d, 0x93)
 
 typedef struct _gpt_header {
 	__le64 signature;
diff --git a/block/partitions/msdos.c b/block/partitions/msdos.c
index b5d5c229cc3b..ff7e74911359 100644
--- a/block/partitions/msdos.c
+++ b/block/partitions/msdos.c
@@ -564,6 +564,15 @@ static void parse_minix(struct parsed_partitions *state,
 #endif /* CONFIG_MINIX_SUBPARTITION */
 }
 
+static void parse_fit_mbr(struct parsed_partitions *state,
+			  sector_t offset, sector_t size, int origin)
+{
+#ifdef CONFIG_FIT_PARTITION
+	u32 extra_slot = 64;
+	(void) parse_fit_partitions(state, offset, size, &extra_slot, 1);
+#endif /* CONFIG_FIT_PARTITION */
+}
+
 static struct {
 	unsigned char id;
 	void (*parse)(struct parsed_partitions *, sector_t, sector_t, int);
@@ -575,6 +584,7 @@ static struct {
 	{UNIXWARE_PARTITION, parse_unixware},
 	{SOLARIS_X86_PARTITION, parse_solaris_x86},
 	{NEW_SOLARIS_X86_PARTITION, parse_solaris_x86},
+	{FIT_PARTITION, parse_fit_mbr},
 	{0, NULL},
 };
 
diff --git a/drivers/mtd/mtd_blkdevs.c b/drivers/mtd/mtd_blkdevs.c
index 44bea3f65060..413c9283321f 100644
--- a/drivers/mtd/mtd_blkdevs.c
+++ b/drivers/mtd/mtd_blkdevs.c
@@ -389,18 +389,8 @@ int add_mtd_blktrans_dev(struct mtd_blktrans_dev *new)
 	gd->minors = 1 << tr->part_bits;
 	gd->fops = &mtd_block_ops;
 
-	if (tr->part_bits)
-		if (new->devnum < 26)
-			snprintf(gd->disk_name, sizeof(gd->disk_name),
-				 "%s%c", tr->name, 'a' + new->devnum);
-		else
-			snprintf(gd->disk_name, sizeof(gd->disk_name),
-				 "%s%c%c", tr->name,
-				 'a' - 1 + new->devnum / 26,
-				 'a' + new->devnum % 26);
-	else
-		snprintf(gd->disk_name, sizeof(gd->disk_name),
-			 "%s%d", tr->name, new->devnum);
+	snprintf(gd->disk_name, sizeof(gd->disk_name),
+		 "%s%d", tr->name, new->devnum);
 
 	set_capacity(gd, ((u64)new->size * tr->blksize) >> 9);
 
diff --git a/drivers/mtd/mtdblock.c b/drivers/mtd/mtdblock.c
index a80809543793..a1f61bcd2c8f 100644
--- a/drivers/mtd/mtdblock.c
+++ b/drivers/mtd/mtdblock.c
@@ -334,7 +334,11 @@ static void mtdblock_remove_dev(struct mtd_blktrans_dev *dev)
 static struct mtd_blktrans_ops mtdblock_tr = {
 	.name		= "mtdblock",
 	.major		= MTD_BLOCK_MAJOR,
+#ifdef CONFIG_FIT_PARTITION
+	.part_bits	= 1,
+#else
 	.part_bits	= 0,
+#endif
 	.blksize 	= 512,
 	.open		= mtdblock_open,
 	.flush		= mtdblock_flush,
diff --git a/drivers/mtd/ubi/block.c b/drivers/mtd/ubi/block.c
index e003b4b44ffa..4cf628499bfe 100644
--- a/drivers/mtd/ubi/block.c
+++ b/drivers/mtd/ubi/block.c
@@ -418,7 +418,11 @@ int ubiblock_create(struct ubi_volume_info *vi)
 
 	gd->fops = &ubiblock_ops;
 	gd->major = ubiblock_major;
+#ifdef CONFIG_FIT_PARTITION
+	gd->minors = 0;
+#else
 	gd->minors = 1;
+#endif
 	gd->first_minor = idr_alloc(&ubiblock_minor_idr, dev, 0, 0, GFP_KERNEL);
 	if (gd->first_minor < 0) {
 		dev_err(disk_to_dev(gd),
@@ -427,6 +431,9 @@ int ubiblock_create(struct ubi_volume_info *vi)
 		goto out_cleanup_disk;
 	}
 	gd->private_data = dev;
+#ifdef CONFIG_FIT_PARTITION
+	gd->flags |= GENHD_FL_EXT_DEVT;
+#endif
 	sprintf(gd->disk_name, "ubiblock%d_%d", dev->ubi_num, dev->vol_id);
 	set_capacity(gd, disk_capacity);
 	dev->gd = gd;
diff --git a/include/linux/msdos_partition.h b/include/linux/msdos_partition.h
index 2cb82db2a43c..c15b6c759aca 100644
--- a/include/linux/msdos_partition.h
+++ b/include/linux/msdos_partition.h
@@ -31,6 +31,7 @@ enum msdos_sys_ind {
 	LINUX_LVM_PARTITION = 0x8e,
 	LINUX_RAID_PARTITION = 0xfd,	/* autodetect RAID partition */
 
+	FIT_PARTITION = 0x2e,		/* U-Boot uImage.FIT */
 	SOLARIS_X86_PARTITION =	0x82,	/* also Linux swap partitions */
 	NEW_SOLARIS_X86_PARTITION = 0xbf,
 
