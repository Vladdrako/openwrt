From c401037d6b0574f82da0594ab679fa60f3bc57bb Mon Sep 17 00:00:00 2001
Message-Id: <c401037d6b0574f82da0594ab679fa60f3bc57bb.1645247254.git.plr.vincent@gmail.com>
From: Vincent Pelletier <plr.vincent@gmail.com>
Date: Sat, 19 Feb 2022 01:57:45 +0000
Subject: [PATCH] netfilter: conntrack: Un-hardcode ratio in htable size
 choice.

On embedded networking devices (such as home routers), the total memory
amount can be quite low, and the original hardcoded 16k divisor cause this
hashtable to be too small for the number of connections the device will
have to handle. In turn, this means that distributions have to increase
net.netfilter.nf_conntrack_max and (ideally)
net.netfilter.nf_conntrack_buckets to some arbitrary value, which often
then hardware-independent (hardcoded value in a sysctl configuration file).
This is impractical, as this means the lowest-memory devices impose a limit
on these values, preventing devices with more memory from making use of it
without user tweaks. All this while the kernel has the logic for
hardware-dependent sizing.
Just as there exist a configuration option for choosing what tick frequency
the kernel should use based on its intended workload (interactive vs.
throughput), expose the divisor as a build-time configuration option.

Signed-off-by: Vincent Pelletier <plr.vincent@gmail.com>
---
 net/netfilter/Kconfig             | 37 +++++++++++++++++++++++++++++++
 net/netfilter/nf_conntrack_core.c |  3 ++-
 2 files changed, 39 insertions(+), 1 deletion(-)

--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -82,6 +82,43 @@ if NF_CONNTRACK
 config NETFILTER_CONNCOUNT
 	tristate
 
+choice
+	prompt 'Connection tracking hashtable memory fraction'
+	default NF_CONNTRACK_MEM_DIV_16K
+	help
+	  Allows the configuration of the ratio between total memory and the
+	  number of conntrach hash table buckets
+	  (net.netfilter.nf_conntrack_buckets) and maximum number of entries
+	  (net.netfilter.nf_conntrack_max).
+	  The lower, the more memory will be allocated for the hash table, and
+	  the higher the maximum number of tracked connections will be.
+	  Note that memory will be allocated for each tracked connection in
+	  addition to the memory needed by the hash table itself.
+
+	config NF_CONNTRACK_MEM_DIV_16K
+		bool '16384'
+	help
+	  Allocates one conntrack hashtable entry per 16384 * sizeof(struct *)
+	  of total memory.
+
+	  If unsure, use this.
+
+	config NF_CONNTRACK_MEM_DIV_1K
+		bool '1024'
+	help
+	  Allocates one conntrack hashtable entry per 1024 * sizeof(struct *)
+	  of total memory.
+
+	  If building for an embedded device handling lots of connections,
+	  consider using this.
+
+endchoice
+
+config NF_CONNTRACK_MEM_DIV
+	int
+	default 16384 if NF_CONNTRACK_MEM_DIV_16K
+	default 1024 if NF_CONNTRACK_MEM_DIV_1K
+
 config NF_CONNTRACK_MARK
 	bool  'Connection mark tracking support'
 	depends on NETFILTER_ADVANCED
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -2576,7 +2576,8 @@ int nf_conntrack_init_start(void)
 
 	if (!nf_conntrack_htable_size) {
 		nf_conntrack_htable_size
-			= (((nr_pages << PAGE_SHIFT) / 16384)
+			= (((nr_pages << PAGE_SHIFT)
+			    / CONFIG_NF_CONNTRACK_MEM_DIV)
 			   / sizeof(struct hlist_head));
 		if (BITS_PER_LONG >= 64 &&
 		    nr_pages > (4 * (1024 * 1024 * 1024 / PAGE_SIZE)))
