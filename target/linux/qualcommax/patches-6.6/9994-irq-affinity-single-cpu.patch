kernel: Don't allow IRQ affinity masks to have more than one CPU

Even with an affinity mask that has multiple CPUs set, IRQs always run
on the first CPU in their affinity mask. Drivers that register an IRQ
affinity notifier (such as pm_qos) will therefore have an incorrect
assumption of where an IRQ is affined.

Fix the IRQ affinity mask deception by forcing it to only contain one
set CPU.

Signed-off-by: Sultan Alsawaf <sultan@kerneltoast.com>

--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -269,6 +269,8 @@
 	 * case we do as we are told).
 	 */
 	cpumask_and(&tmp_mask, prog_mask, cpu_online_mask);
+	/* IRQs only run on the first CPU in the affinity mask; reflect that */
+	mask = cpumask_of(cpumask_first(mask));	
 	if (!force && !cpumask_empty(&tmp_mask))
 		ret = chip->irq_set_affinity(data, &tmp_mask, force);
 	else if (force)

kernel: Only set one CPU in the default IRQ affinity mask

On ARM, IRQs are executed on the first CPU inside the affinity mask, so
setting an affinity mask with more than one CPU set is deceptive and
causes issues with pm_qos. To fix this, only set the CPU0 bit inside the
affinity mask, since that's where IRQs will run by default.

This is a follow-up to "kernel: Don't allow IRQ affinity masks to have
more than one CPU".

Signed-off-by: Sultan Alsawaf <sultan@kerneltoast.com>

--- a/kernel/irq/irqdesc.c
+++ b/kernel/irq/irqdesc.c
@@ -42,7 +42,7 @@
 	if (!cpumask_available(irq_default_affinity))
 		zalloc_cpumask_var(&irq_default_affinity, GFP_NOWAIT);
 	if (cpumask_empty(irq_default_affinity))
-		cpumask_setall(irq_default_affinity);
+		cpumask_set_cpu(0, irq_default_affinity);
 }
 #else
 static void __init init_irq_default_affinity(void)

